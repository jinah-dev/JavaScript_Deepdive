## 😀 함수란?

: 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의
-> 매개변수, 인수, 반환값
--> 함수는 **객체 타입의 값**이다
-> **함수 정의**를 통해 생성 (정의는 여러 방법이 존재)

### ❤️ 함수의 장점

- 재사용성을 높이고, 유지보수의 편의성을 높임. 실수를 줄여 코드의 신뢰성을 높임
- 가독성 향상 시킴

## 😀 함수 리터럴

```js
var f = function add(x, y) {
  return x + y;
};
```

-> 함수 리터럴도 평가되어 **값**을 생성 (**객체** 값으로 평가됨)
-> 함수 객체는 호출 가능
-> 함수 이름 생략 가능 (**익명함수**)
-> **표현식인 문 (객체 값)**

## 😀 함수 정의

: 함수 호출 이전에 매개변수, 실행문, 반환값 지정하는 것
-> **정의된 함수는 자바스크립트 엔진에 의해 평가되어 함수 객체**

### 1. 함수 선언문

```js
function add(x, y) {
  return x + y;
}
```

-> 함수 리터럴과 형태 동일
-> **함수 이름 생략 불가능**
-> **표현식이 아닌 문**
-> **호이스팅 발생** (함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작)
--> 변수에 할당될 수 없지만, 함수 리터럴과 형태가 같아, 문맥에 따라 함수 리터럴도 평가되어, 변수에 할당될 수도
-> 자바스크립트 엔진에 의해 함수 선언문 해석하고, 함수 객체 생성
-> **자바스크립트 엔진은 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 생성하고, 함수 객체 할당 **

--> 함수 리터럴은 표현식인 문이라 변수에 할당할 수 있고, 객체 값 반환. 함수 선언문도의 함수 정의 시, 자바스크립트 엔진에 의해 함수 이름과 같은 이름은 식별자를 생성하고, 함수 객체 할당
--> 함수 선언문은 표현식이 아닌 문인데, 왜 객체 값 할당,,? 왜 값으로 평가됨?

### 2. 함수 표현식

```js
var add = function (x, y) {
  return x + y;
};
```

: **일급 객체**(값의 성질 갖는 객체)이므로, 객체를 변수에 할당 가능
-> 표현식인 문
-> add라는 변수가 호이스팅이 일어나지만, 할당은 런타임에서 발생!
-> 함수 선언 이전에, 함수 생성이 되지않으므로, 함수 사용 불가
-> 함수 선언문은 함수 자체가 호이스팅이 되므로, 선언 전에, 함수 사용 가능

### 3. Function 생성자 함수

```js
var add = new Function("x", "y", "return x+y");
```

### 4. 화살표 함수

```js
var add = (x, y) => x + y;
```

-> function 키워드 대신 화살표를 사용해 간략한 방법으로 함수 선언
-> 항상 **익명함수**로 정의

--> 함수 정의는 4가지의 방식이 있는데, 모두 자바스크립트 엔진의 의해 함수 객체를 생성한다!! 또한, 함수 이름은 함수 몸체 내에서만 식별 가능하고, 호출 시에는 식별자로 해야함

## 😀 함수 호출

: 매개변수(파라미터)를 통해 인수(아규먼트)를 전달한다.
-> **인수**는 값으로 평가될 수 있는 **표현식**
-> 매개변수로 전달 시, **undefined로 초기화된 이후에, 인수가 할당!**
-> 매개변수는 함수 몸체 내부에서만 참조할 수 있음
-> **매개변수와 인수의 개수가 일치하는지 체크하지 않음!**

- 인수의 갯수가 모잘란 경우: 매개변수의 값 undefined
- 매개변수의 수가 더 많은 경우: 인자 순서대로 할당하고 나머지 매개변수 무시

--> **매개변수는 최대한 적게. 3개 이상을 넘지 않는 것이 좋다**

## 😀 참조에 의한 방식의 부작용

: 외부의 값에 의존해서, 외부의 값을 변경해버림
-> 최대한 이런 외부의 값에 의존하고, 외부 값을 변경해버리는 상황을 피해야 함

## 😀 함수의 다양한 형태

### 1. 즉시 실행 함수

: 함수 정의와 동시에 즉시 호출되는 함수 (단 한번만 호출)
-> (...) 그룹 연산자로 감싸야 함!!

```js
(function () {
  var a = 3;
  var b = 5;
  return a * b;
})();
```

-> 기명 실행함수도 가능 (함수 리터럴로 인식해서, 함수 이름은 함수 몸체 내에서만 사용 가능-> 함수 외부에서 호출 불가)

### 2. 재귀 함수

: 자기 자신을 호출하는 함수
-> 반복을 줄이기 위해 사용
-> 무한루프에 빠질 위험, 스택 오버플로 에러 발생시킬 수 있으므로
-> 한정적으로 사용하자!!!!

### 3. 중첩 함수

: 함수 내에 함수가 중첩되어 있는 형태
-> 함수 내부에 정의된 함수: **중첩 함수** (외부함수를 돕는 **헬퍼함수**)
-> 중첩함수를 포함하는 함수: **외부 함수**

```js
function outer() {
  var x = 1;
  function inner() {
    var y = 2;
    console.log(x + y);
  }
  inner();
}
outer();
```

### 4. 콜백 함수

: **매개변수를 통해 다른 함수의 내부로 전달되는 함수**
-> 고차함수: 그 콜백을 받는 함수
-> 고차함수는 콜백 함수를 자신의 일부분으로 합성
-> 비동기 처리에 많이 사용!!!

### 5. 순수함수와 비순수 함수

- **순수 함수**: **어떤 외부 상태에도 의존하지 않으며 외부 상태를 변경하지 않는 함수**
  -> 동일한 인수 전달되면 동일한 값 반환
- **비순수 함수**: 외부 상태에 의존하게 되어 반환값이 변할 수 있고, 외부 상태도 변경할 수 있음
  --> 순수함수를 사용하도록 하자. 외부 상태 변경하고, 외부에 의존하는 거 지양하자!

## 핵심

- 함수는 **객체** 타입의 **값**이다. **일급 객체**이다. (값의 성질을 갖는 객체)
- 함수 이름은 함수 몸체 내부에서만 유효한 식별자
- 함수 호출은 함수 이름이 아닌 **식별자**로
- 함수 리터럴과 함수 표현식은 표현식인 문/함수 선언문은 표현식이 아닌 문!
- 함수 표현식은 gkatn 호이스팅이 일어나지 않음-> 선언 전에 사용불가/ 함수 선언문은 호이스팅 일어나서, 선언 전에 사용 가능
- 화살표 함수는 항상 익명 함수로 정의

### 1. 함수 표현식 사용하자 (함수 호이스팅 일어나지 않음), 객체 값 생성

### 2. 재귀함수는 오버플로우, 무한루프 문제 발생할 수 있으므로 진짜 필요할 때 사용하자

### 3. 콜백함수는 파라미터로 전달해서 다른 함수의 내부로 전달되는 함수로, 비동기에서 많이 사용된다.

### 4. 외부 데이터에 의존하지 않고, 외부 값을 변경하지 않는 순수함수를 사용하자
