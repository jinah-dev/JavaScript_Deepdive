## 😀 자바스크립트 객체의 분류

### 1. 표준 빌트인 객체

: ECMAScript 사양에 정의된 객체
-> 애플리케이션 전역의 공통 기능 제공
-> 별도의 선언 없이 전역 변수처럼 언제나 참조 가능

### 2. 호스트 객체

: 자바스크립트 실행 환경(브라우저, Node.js)에서 추가로 제공하는 객체

### 3. 사용자 정의 객체

: 기본 제공되는 개체가 아닌 사용자가 직접 정의한 객체

## 😀 표준 빌트인 객체

: Object, String, Number, Boolean, Symbol, Date, Math, RegExp, Array, Map/Set, Function, Promise, Reflext, Proxy, Json, Error등 40 여개의 표준 빌트인 객체 제공
-> Math, Reflext, Json을 제외한 나머지는 모두 **인스턴스를 생성**할 수 있는 **생성자 함수 객체**
-> 생성자 함수 객체인 표준 빌트인 객체: 프로토타입 메서드, 정적 메서드 제공
-> 그냥 표준 빌트인 객체: 정적 메서드만 제공

```js
const a = new String("Lee");
const b = new Number(123);
const c = new Boolean(true);
```

-> 인스턴스의 프로토타입은 표준 빌트인 객체의 prototype 프로퍼티에 바인딩된 객체
ex) String 인스턴스의 프로토타입은 **String.prototype**
-> 빌트인 프로토타입 메서드 제공/ 빌트인 객체: 정적 메서드 제공
-> 프로토타입 메서드는 모든 인스턴스가 상속받아 사용 가능
ex)

```js
const num = new Number(1.5);
console.log(num.toFixed());
```

--> 표준 빌트인 객체는 ECMAScript에 정의된 객체로, 전역 객체이다. 자바스크립트에는 40여 개의 표준 빌트인 객체가 존재하고, 몇몇의 제외하고는 생성자 함수 객체로, 인스턴스를 생성할 수 있다. 해당 인스턴스의 프로토타입은 해당 표준 빌트인 객체의 prototype 프로퍼티에 바인딩된 객체이다. 그리고 각각의 인스턴스는 해당 프로토타입의 메서드를 상속받아, 사용할 수 있고, 표준 빌트인 객체의 정적 메서드 또한 사용할 수 있다.

## 😀 원시값과 래퍼 객체

: 원시값은 객체가 아니라 프로퍼티나 메서드를 가질 수 없음에도 객체 처럼 동작하는 이유는 래퍼 객체라는 임시 객체가 생성되기 때문

- **래퍼 객체** (wrapper object)
  **: 문자열, 숫자, 불리언 값에 대해서 객체처럼 접근하면 생성되는 임시 객체**
  -> 자바스크립트 엔진에 의해, 원시값을 연관된 객체를 생성(래퍼객체)하여, 해당 객체의 프로퍼티나 메서드에 접근 이후 다시 원시값으로 돌아옴

```js
const str = "hi";
console.log(str.length); //2
console.log(str.toUpperCase()); //HI
console.log(typeof str); //string
```

-> 래퍼 객체인 String 생성자 함수의 인스턴스는 String.prototype의 메서드를 상속받아 사용 가능
-> **null, undefined는 래퍼 객체 생성하지 않음**

## 😀 전역 객체

: 코드가 실행되기 이전 단계에서 자바스크립트 엔진에 의해 가장 먼저 생성되는 객체로, 어떤 객체에도 속하지 않는 **최상위 객체**

- 브라우저 환경: window/ Node.js 환경: global
  -> **표준 빌트인 객체와 호스트 객체, var 키워드로 선언한 전역 변수, 전역함수를 프로퍼티로 가짐**
  -> let, const로 선언한 전역 변수는 전역 객체의 프로퍼티가 아님. 보이지 않는 개념적인 블록 내에 존재!!!
  -> window.~ 이지만, window는 생략 가능

### ❤️ 빌트인 전역 프로퍼티

: 전역 객체의 프로퍼티로, 애플리케이션 전역에서 사용하는 값을 제공

#### 1. Infinity

: 무한대를 나타내는 숫자값

```js
console.log(3 / 0); //양의 무한대 Infinity
console.log(-3 / 0); //음의 무한대 -Infinity
console.log(typeof Infinity); //number
```

#### 2. NaN

: 숫자가 아님을 나타냄

```js
console.log(window.NaN);
console.log(Number("xyz"));
console.log(1 * "string");
console.log(typeof NaN);
```

#### 3. undefined

: 원시 타입 undefined를 값으로 가짐

### ❤️ 빌트인 전역 메서드

: 전역 객체의 메서드로, 애플리케이션 전역에서 호출할 수 있는 빌트인 메서드

#### 1. eval

: 문자열을 인수로 전달받아서, 실행 결과 돌려줌

- **표현식인 경우**
  : 문자열 코드를 런타임에 평가하여 **값 생성**
- **표현식이 아닌 문인 경우**
  : 런타임에 **실행**

```js
//표현식인 문 (값 생성)
eval("1+2"); //3
//표현식이 아닌 문 (실행)
eval("var x - 5;"); //undefined
```

-> 인수로 전달받은 문자열이 여러 개의 문으로 이루어져 있다면, **마지막 결괏값 반환**

```js
const x = 1;
function foo() {
  eval("var x = 2;");
  console.log(x); //2
}

foo();
console.log(x); //1
```

-> 기존의 스코프를 런타임에 동적으로 수정
-> 원래 전역 단위이지만, foo함수 단위로 스코프 수정

#### 2. isFinite

: 전달받은 인수가 유한수인지 검사 (유한수이면 true 반환)
-> 숫자가 아닌 경우, 숫자로 타입 변환 후 검사 수행 (NaN으로 평가되는 값이라면 false 반환)

```js
isFinite(0); //true
isFinite(2e64); //true
isFinite("10"); //true
isFinite(null); //true
```

#### 3. isNaN

: 전달받은 인수가 NaN인지 검사
-> 숫자 타입이 아닌 경우 숫자로 변환 후 검사 수행

```js
isNaN(NaN); // true
isNaN("blabla"); //true
```

#### 4. parseFloat

: 실수로 해석하여 반환 (부동 소수점)
-> 공백으로 구분된 문자열은 첫 번째 문자열만 반환
-> 첫 번째 문자열을 숫자로 변환할 수 없다면 NaN을 반환
-> 앞 뒤 공백은 무시

```js
parseFloat("3.14"); //3.14
parseFLoat("34 45 66"); //34
parseFloat("He was 40"); //NaN
parseFloat(" 60 "); //60
```

#### 5. parseInt

: 정수로 해석하여 반환
-> 2번째 인자는 기수를 지정
-> 2번째 인수를 지정하지 않더라도, 첫 번째 인수로 전달된 문자열이 '0x', '0X'로 시작하면, 16진수라고 인식하고 10진수로 변환해줌

```js
parseInt("10", 2); //2
```

-> 2진수 리터럴, 8진수 리터럴은 제대로 해석하지 못함

```js
parseInt("0b10"); //0
parseInt("0o10"); //0
```

#### 6. encodeURI/decodeURI

- **encodeURI**
  : 이스케이프 처리를 위해 인코딩
  -> URL 내에서 의미를 갖고 있는 문자(%, ?, #)나 URL에 올 수 없는 문자(한글, 공백), 시스템에 의해 해석될 수 있는 문자(<, >)를 이스케이프 처리
  -> 0~9의 숫자/ -\_.!~\*'() 문자는 이스케이프 처리에서 제외
- **decodeURI**
  : 인코딩 처리 이전으로 되돌려줌

### ❤️ 암묵적 전역

```js
var x = 10;

function foo() {
  y = 20;
}
foo();

console.log(x + y);
```

-> y는 선언하지 않은 식별자이다. 전역 객체 프로퍼티를 동적으로 생성하여 전역 변수 처럼 동작
-> 변수가 아니므로 변수 호이스팅이 발생하지 않는다
-> 변수가 아니므로, 프로퍼티이므로 삭제 가능
**delete y**

### ⭕ 핵심

1. 표준빌트인 객체는 전역 객체로, 애플리케이션 전역에서 생성된 객체
2. 원시값은 래퍼 객체 생성으로, 프로퍼티와 메서드 사용 후 다시 원시값으로
3. 전역 객체는 프로퍼티와 메서드 존재
4. 암묵적 전역은 선언되지 않은 식별자로서, 전역 객체의 프로퍼티가 동적으로 생성됨 (전역 변수는 아님, 처럼 동작)
